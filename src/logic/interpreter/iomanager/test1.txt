# CRs

# A class CR
    SetLabel CRA, Libre             @CR: A class
    SetD CRA, 0                     @a1=0
    SetLibre Libre+1
    SetActual Libre
#-----------------------------------------------------------------------------

# VTs

# A class VT
    SetLabel VTA, Libre             @ VT_A: A class
    SetD Libre, initA               @VT_A: constructorA
    SetD Libre + 1, m1A               @VT_A: m1A
    SetD Libre+2, m1PA              @VT_A: m1PA
    SetLibre Libre+3
    SetActual Libre

# B class VT
    SetLabel VTB, Libre             @VT_A: B class
    SetD Libre, initB               @VT_B: constructorB
    SetD Libre+1, m1B               @VT_B: m1B
    SetD Libre+2, m1PA              @VT_B: m1PA
    SetD Libre+3, m2B               @VT_B: m2B
    SetD Libre+4, VTA               @VT_B: VTA
    SetLibre Libre+5 
    SetActual Libre

# C class VT
    SetLabel VTC, Libre             @VT_A: C class
    SetD Libre, initC               @VT_C: constructorC
    SetD Libre+1, m1B               @VT_C: m1B
    SetD Libre+2, m1PC              @VT_C: m1PC
    SetD Libre+3, m2B               @VT_C: m2B
    SetD Libre+4, m2PC              @VT_C: m2PC
    SetD Libre+5, m3C               @VT_C: m3C
    SetD Libre+6, VTB               @VT_C: VTB
    SetLibre Libre+7
    SetActual Libre

# Principal class VT
    SetLabel VTPrincipal, Libre
    SetLibre Libre+1                @VT_Principal
    SetActual Libre
#-----------------------------------------------------------------------------

# main code invocation
        SetD Libre, PC+5            @PTR a halt
        SetD Libre+1, actual        @ED
        SetActual Libre
        SetLibre Actual+5           # Dejo los espacios suficientes para las variables locales
        Jump Main
        Halt

#-----------------------------------------------------------------------------
# calls to class A: a(), m1(), m1(int x)

# Class A --> method A (init)
initA   SetH D[Actual+2]+1, 1           			    @v1 = 1
	SetH D[Actual+2]+2, 20                                      @v2 = 20
        SetLibre Actual
        SetActual D[Libre+1]
        Jump D[Libre]
#%%-----------------------------------------------------------------------------

# Class A --> method m1A
m1A     SetD Actual+3, 0                                            @i=0
for     JumpT endfor, !(D[Actual + 3] < (H[D[Actual+2]+1] + H[D[Actual+2]+2]))       # salto al final del for si...
        SetH D[Actual+2]+1, H[D[Actual+2]+1] + D[Actual + 3]         @v1=v1+i
        SetH D[Actual+2]+2, H[D[Actual+2]+2] - D[Actual + 3]         @v2=v2-i
        SetD Actual+3, D[Actual+3] +1                               @i+=1
        JumpT endfor, (H[D[Actual+2]+1] + H[D[Actual+2]+2]) >= 100  @break
        Jump for                                                    @for
endfor  SetD  CRA, D[CRA] + 1                                       @a1=a1+1

        SetD Actual-1, H[D[Actual + 2] + 1] + H[D[Actual + 2] + 2]  @Lugar_retorno=v1+v2

        SetLibre Actual
        SetActual D[Libre + 1]
        Jump D[Libre]

#-----------------------------------------------------------------------------

# Class A --> method m1PA
m1PA    SetD CRA, D[CRA]+1                                          @a1=a1+1
        SetD Actual-1, D[CRA]                                       @return a1
        SetLibre Actual
        SetActual D[Libre+1]
        Jump D[Libre]

#%%-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
# calls to class B: m2(), m1()

# Class B --> method initB
# super: A class
# RA de initA
initB   SetD Libre, PC + 6                                          @PTR
        SetD Libre + 1, Actual                                      @ED
        SetD Libre + 2, D[Actual+2]                                 @this
        SetActual Libre
        SetLibre Actual+3
        Jump D[VTA]                                                 @super()

        SetH D[Actual+2]+3, D[CRA]*3                                @v3=a1*3
# return
        SetLibre Actual
        SetActual D[Libre+1]
        Jump D[Libre]

#-----------------------------------------------------------------------------

# Class B --> method m1B
m1B         SetD Actual+3, 0                        @j=0
            JumpT bloque3, D[CRA] == 1              @case1
            JumpT bloque3, D[CRA] == 2              @case2
            JumpT bloque3, D[CRA] == 3              @case3
            JumpT bloque6, D[CRA] == 4              @case4
            JumpT bloque6, D[CRA] == 5              @case5
            JumpT bloque6, D[CRA] == 6              @case6
            Jump bloqueDef                          @caseDef

bloque3     SetD Actual+3, 3 * D[CRA]+1             @j=3*a1+1
            Jump break
bloque6     SetD Actual+3, H[D[Actual+2]+1] + 12    @j=v1+12
            Jump break
bloqueDef   SetD Actual+3, 1                        @j=1
            Jump break
# RA m1(int x) en A
break       SetLibre Libre + 1                      @lugar_retorno_m1PA
            SetD Libre, PC + 7                      @PTR
            SetD Libre + 1, Actual                  @ED
            SetD Libre + 2, D[Actual+2]             @this
            SetD Libre + 3, D[Actual+3]             @x
            SetActual Libre
            SetLibre Actual+4
            Jump D[VTA+2]                           @super.m1(j)

            SetD Actual-1, D[Libre-1]               @lugar_retorno=super.m1(j)
            SetLibre Libre-1

            SetLibre Actual
            SetActual D[Libre+1]
            Jump D[Libre]

#-----------------------------------------------------------------------------

# Class B --> method m2B
m2B     SetD CRA, D[CRA]+1                              @a1=a1+1
        SetD Actual-1, H[D[Actual+2]+3] + D[CRA]        @lugar_retorno=(v3+a1)
# RA m1() en A
        SetLibre Libre + 1                              @Lugar_retorno
        SetD Libre, PC + 6                              @PTR
        SetD Libre + 1, Actual                          @ED
        SetD Libre + 2, D[Actual + 2]                   @this
        SetActual Libre
        SetLibre Actual+4                               @dejo un espacio para las variables

        Jump D[VTA+1]                                   @super.m1()
        SetD Actual-1, D[Actual-1] + D[Libre-1]         @lugar_retorno=(v3+a1)+super.m1() # el resultado estar√° en el siguiente libre
        SetLibre Libre-1                                # para que no haya un espacio sin usar, del lugar de retorno anterior
# RA m1() en B
        SetLibre Libre+1                                @lugar_retorno
        SetD Libre, PC + 6
